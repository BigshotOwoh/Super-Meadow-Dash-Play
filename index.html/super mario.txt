<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Garden Dash â€“ 2D Platformer (Multiâ€‘Level)</title>
  <style>
    html, body { height: 100%; margin: 0; background:#6ec3ff; overflow:hidden; }
    #game { position: fixed; inset: 0; width: 100vw; height: 100svh; }
    .overlay { position: fixed; left: 0; right: 0; top: 0; padding: 8px 12px; font-family: system-ui, Arial, sans-serif; color: #04243a; text-shadow: 0 1px 0 rgba(255,255,255,.4); pointer-events: none; }
    .bottom-note { position: fixed; bottom: 8px; left: 50%; transform: translateX(-50%); font: 12px/1.2 system-ui, Arial; color: #033; opacity:.7; pointer-events:none; }
    .win { position: fixed; inset: 0; display: none; place-items: center; background: rgba(0,0,0,.35); }
    .win .card { background: white; padding: 24px 28px; border-radius: 14px; box-shadow: 0 20px 60px rgba(0,0,0,.25); font-family: system-ui, Arial; text-align: center; width: min(520px, 92vw); }
    .btn { display:inline-block; margin-top:12px; padding:10px 14px; border-radius:10px; border:0; background:#0ea5e9; color:white; font-weight:600; cursor:pointer; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.js"></script>
</head>
<body>
  <div id="game"></div>
  <div class="overlay" id="hud">Lvl 1 Â· Time: 0.0s Â· Score: 0 Â· Coins: 0 Â· Lives: 3</div>
  <div class="bottom-note">Controls: WASD or Arrow Keys to move Â· Space to jump (double jump) Â· Stomp enemies</div>
  <div class="win" id="win">
    <div class="card">
      <h2 style="margin:0 0 8px" id="winTitle">Level Complete ðŸŽ‰</h2>
      <p id="summary" style="margin:0 0 12px; color:#145;"></p>
      <div id="nextBtns">
        <button class="btn" id="nextLevelBtn">Next Level â–¶</button>
        <button class="btn" id="restartBtn" style="display:none">Play Again</button>
      </div>
    </div>
  </div>
<script>
(() => {
  // ----------------------
  // Tiny audio synth (SFX + simple BGM)
  // ----------------------
  const audio = {
    ctx: null,
    master: null,
    start() {
      if (this.ctx) return;
      this.ctx = new (window.AudioContext || window.webkitAudioContext)();
      this.master = this.ctx.createGain();
      this.master.gain.value = 0.06; // quiet by default
      this.master.connect(this.ctx.destination);
      musicLoop();
    },
    beep(freq = 440, dur = 0.08, type='square', vol=0.12) {
      if (!this.ctx) return;
      const o = this.ctx.createOscillator();
      const g = this.ctx.createGain();
      o.type = type;
      o.frequency.value = freq;
      g.gain.value = vol;
      o.connect(g); g.connect(this.master);
      const now = this.ctx.currentTime;
      o.start(now);
      g.gain.setValueAtTime(vol, now);
      g.gain.exponentialRampToValueAtTime(0.0001, now + dur);
      o.stop(now + dur + 0.01);
    }
  };

  let musicTimer = null;
  function musicLoop(){
    if (!audio.ctx) return;
    if (musicTimer) clearInterval(musicTimer);
    const notes = [262, 294, 330, 392, 330, 294, 262, 196];
    let i = 0;
    musicTimer = setInterval(() => {
      // pad
      const o = audio.ctx.createOscillator();
      const g = audio.ctx.createGain();
      o.type = 'sine'; o.frequency.value = notes[i % notes.length] / 2; g.gain.value = 0.02;
      o.connect(g); g.connect(audio.master);
      const now = audio.ctx.currentTime; o.start(now);
      g.gain.setValueAtTime(0.02, now);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.45);
      o.stop(now + 0.47);
      // lead
      audio.beep(notes[i % notes.length], 0.10, 'square', 0.10);
      i++;
    }, 450);
  }

  // ----------------------
  // Level data (pits removed for smooth ground)
  // ----------------------
  const LEVELS = [
    // Level 1 â€“ gentle
    {
      worldW: 5200,
      pits: [],
      staticPlats: [
        [360,420],[520,360],[940,380],[1120,320],[1380,300],[1750,360],[1850,280],[2050,340],
        [2550,300],[2680,240],[2860,280],[3350,350],[3520,280],[3660,240],[4100,360],[4360,320]
      ],
      movingPlats: [
        {x:1280,y:420,dx:200,dy:0,t:2200}, {x:2200,y:260,dx:0,dy:140,t:1800},
        {x:3100,y:360,dx:240,dy:0,t:2400}, {x:4500,y:300,dx:0,dy:180,t:2000}
      ],
      enemies: [ [800,360],[1600,200],[1900,220],[2600,220],[3400,200],[3600,200],[4200,200],[4700,200] ],
      coins: [ [480,320],[960,320],[1260,380],[1760,320],[2060,260],[2660,200],[3120,300],[3360,300],[3660,200],[3860,220],[4460,240] ],
      goalX: 5080
    },
    // Level 2 â€“ more platforms and coins
    {
      worldW: 6200,
      pits: [],
      staticPlats: [
        [360,420],[520,360],[820,300],[980,260],[1500,340],[1680,260],[1860,220],[2300,300],
        [2480,240],[2660,200],[3000,260],[3180,320],[3640,260],[3820,220],[4200,320],[4560,280], [4920,240], [5480,300]
      ],
      movingPlats: [
        {x:1200,y:360,dx:260,dy:0,t:2000},{x:2000,y:240,dx:0,dy:160,t:1800},
        {x:2900,y:360,dx:260,dy:0,t:2300},{x:3800,y:260,dx:0,dy:180,t:2000}, {x:5200,y:320,dx:240,dy:0,t:2100}
      ],
      enemies: [ [900,200],[1700,200],[2100,200],[2500,200],[3000,200],[3500,200],[4000,200],[4600,200],[5200,200] ],
      coins: [ [700,280],[1000,240],[1400,300],[1800,240],[2050,200],[2400,200],[2750,260],[3120,220],[3440,220],[3720,200],[4100,260],[4480,220],[5060,260],[5400,280],[5800,280] ],
      goalX: 6060
    },
    // Level 3 â€“ faster patrols, trickier jumps
    {
      worldW: 7200,
      pits: [],
      staticPlats: [
        [440,420],[640,360],[1000,320],[1180,280],[1560,320],[1760,260],[2060,300],[2260,240],
        [2560,220],[2960,260],[3360,240],[3560,220],[3960,300],[4260,280],[4660,260],[4960,240],[5360,260],[5960,300]
      ],
      movingPlats: [
        {x:900,y:360,dx:280,dy:0,t:1800},{x:1700,y:260,dx:0,dy:180,t:1700},
        {x:2500,y:320,dx:300,dy:0,t:1900},{x:3300,y:260,dx:0,dy:200,t:1700},{x:4400,y:300,dx:320,dy:0,t:1800}, {x:6000,y:280,dx:0,dy:200,t:1600}
      ],
      enemies: [ [760,200],[1360,200],[1860,200],[2460,200],[3060,200],[3660,200],[4260,200],[4860,200],[5460,200],[6060,200] ],
      coins: [ [620,320],[980,280],[1260,240],[1620,300],[1980,240],[2340,220],[2760,260],[3120,220],[3480,220],[3840,260],[4140,240],[4520,220],[4860,260],[5220,300],[5620,280],[6020,260],[6460,240],[6820,260] ],
      goalX: 7040
    }
  ];

  // ----------------------
  // Phaser Setup
  // ----------------------
  const WORLD_H = 540;
  let WORLD_W = LEVELS[0].worldW;

  const config = {
    type: Phaser.AUTO,
    parent: 'game',
    backgroundColor: '#7fd1ff',
    physics: { default: 'arcade', arcade: { gravity: { y: 1400 }, debug: false } },
    scale: { mode: Phaser.Scale.RESIZE, autoCenter: Phaser.Scale.CENTER_BOTH },
    scene: { preload, create, update }
  };

  let game = new Phaser.Game(config);

  // Globals within scene
  let sceneRef, player, cursors, keys, ground, platformsStatic, platformsMoving, enemies, goal, clouds, birds, coinsGroup;
  let onMovingPlatform = null;
  let startTime = 0, elapsed = 0, totalCoins = 0, score = 0, lives = 3, finishedLevel = false;
  let levelIndex = 0;
  let lastCheckpoint = { x: 80, y: 360 };
  let levelStartTime = 0;

  function preload(){
    // --- vector textures ---
    const g = this.make.graphics({ x:0, y:0, add:false });

    // Ground tile (garden)
    g.fillStyle(0x5fb957, 1); g.fillRect(0, 0, 64, 24); // grass
    g.fillStyle(0x7a4e2d, 1); g.fillRect(0, 24, 64, 24); // soil
    g.generateTexture('tile_ground', 64, 48); g.clear();

    // Static platform
    g.fillStyle(0x3c9e44, 1); g.fillRect(0, 0, 120, 18);
    g.lineStyle(4, 0x2d7e35, 1); g.strokeRect(0,0,120,18);
    g.generateTexture('platform', 120, 18); g.clear();

    // Moving platform
    g.fillStyle(0x3a86ff, 1); g.fillRect(0, 0, 140, 18);
    g.lineStyle(4, 0x225bb5, 1); g.strokeRect(0,0,140,18);
    g.generateTexture('platform_move', 140, 18); g.clear();

    // Clouds
    g.fillStyle(0xffffff, 1);
    g.fillCircle(30,20,20); g.fillCircle(50,15,25); g.fillCircle(70,20,20); g.fillRect(30,20,40,18);
    g.generateTexture('cloud', 100, 50); g.clear();

    // Improved bird (two frames: wing up/down)
    // Frame: wing up
    drawBird(g, 'bird_up', true);
    // Frame: wing down
    drawBird(g, 'bird_down', false);

    // Player (original cheerful adventurer)
    g.fillStyle(0x000000, 0); g.fillRect(0,0,40,56);
    // shoes
    g.fillStyle(0x111111,1); g.fillRect(6,48,12,6); g.fillRect(22,48,12,6);
    // pants stripes
    for(let i=0;i<5;i++){ g.fillStyle(i%2?0x1e40af:0xdc2626,1); g.fillRect(6+i*6,32,6,16); }
    // shirt
    g.fillStyle(0xdc2626,1); g.fillRect(6,20,28,14);
    // gloves
    g.fillStyle(0xffffff,1); g.fillRect(2,28,8,8); g.fillRect(30,28,8,8);
    // head
    g.fillStyle(0xffd7b5,1); g.fillRect(10,6,20,14);
    // eyes
    g.fillStyle(0x000000,1); g.fillRect(14,10,2,3); g.fillRect(24,10,2,3);
    // cap (blue)
    g.fillStyle(0x2563eb,1); g.fillRect(8,2,24,8);
    g.generateTexture('hero', 40, 56); g.clear();

    // Enemy (shadowy with cape + short dagger)
    g.fillStyle(0x000000, 0); g.fillRect(0,0,40,54);
    // feet
    g.fillStyle(0x222222,1); g.fillRect(6,46,12,6); g.fillRect(22,46,12,6);
    // body dark
    g.fillStyle(0x2b2b2b,1); g.fillRect(10,22,20,22);
    // cape (tattered)
    g.fillStyle(0x000000,1); g.fillTriangle(10,22, 2,40, 10,44); g.fillTriangle(30,22, 38,40, 30,44);
    // hooded head
    g.fillStyle(0x1a1a1a,1); g.fillRect(10,8,20,16);
    // eyes
    g.fillStyle(0xffffff,1); g.fillRect(14,14,4,3); g.fillRect(22,14,4,3);
    // dagger
    g.fillStyle(0xaaaaaa,1); g.fillRect(2,30,8,2); g.fillStyle(0x888888,1); g.fillTriangle(0,29, 2,31, 6,30);
    g.generateTexture('enemy', 40, 54); g.clear();

    // Goal gate
    g.fillStyle(0x0ea5e9,1); g.fillRect(0,0,32,80);
    g.fillStyle(0x22d3ee,1); g.fillRect(6,6,20,68);
    g.generateTexture('goal', 32, 80); g.clear();

    // Coin
    drawCoin(g);
  }

  function drawBird(g, key, wingUp){
    g.clear();
    // body
    g.fillStyle(0x333844, 1); g.fillEllipse(22,12,26,16); // body
    // head
    g.fillStyle(0x333844, 1); g.fillCircle(34,10,8);
    // eye
    g.fillStyle(0xffffff,1); g.fillCircle(36,9,2.5); g.fillStyle(0x000000,1); g.fillCircle(36,9,1.2);
    // beak
    g.fillStyle(0xf59e0b,1); g.fillTriangle(41,10, 47,8, 47,12);
    // wing
    g.fillStyle(0x2a2f3a,1);
    if (wingUp){
      g.fillTriangle(14,10, 2,0, 4,18);
    } else {
      g.fillTriangle(14,14, 2,24, 6,8);
    }
    g.generateTexture(key, 50, 28);
    g.clear();
  }

  function drawCoin(g){
    g.clear();
    g.fillStyle(0xfde047,1); g.fillCircle(12,12,12);
    g.lineStyle(3,0xf59e0b,1); g.strokeCircle(12,12,10);
    g.fillStyle(0xfff7ad,1); g.fillRect(10,4,4,16); // shine stripe
    g.generateTexture('coin', 24, 24);
    g.clear();
  }

  function create(){
    sceneRef = this;
    // Enable audio context on first input
    this.input.once('pointerdown', () => audio.start());
    this.input.keyboard.on('keydown', () => audio.start());

    buildSceneForLevel(this, levelIndex);

    document.getElementById('nextLevelBtn').onclick = () => {
      if (levelIndex < LEVELS.length - 1){
        nextLevel();
      } else {
        location.reload();
      }
    };
    document.getElementById('restartBtn').onclick = () => location.reload();
  }

  function buildSceneForLevel(scene, idx){
    finishedLevel = false;
    lastCheckpoint = { x: 80, y: 360 };
    levelStartTime = performance.now();

    const LV = LEVELS[idx];
    WORLD_W = LV.worldW;

    // Clear previous groups if they exist
    if (ground) ground.clear(true,true);
    if (platformsStatic) platformsStatic.clear(true,true);
    if (platformsMoving) platformsMoving.clear(true,true);
    if (enemies) enemies.clear(true,true);
    if (coinsGroup) coinsGroup.clear(true,true);
    if (goal) goal.destroy();

    // Parallax background (draw once)
    if (!clouds) createBackground(scene);

    // Physics groups
    ground = scene.physics.add.staticGroup();
    platformsStatic = scene.physics.add.staticGroup();
    platformsMoving = scene.physics.add.group({ allowGravity:false, immovable:true });
    enemies = scene.physics.add.group({ collideWorldBounds:true });
    coinsGroup = scene.physics.add.group({ allowGravity:false, immovable:true });

    // Build smooth ground (no pits)
    const groundY = 500;
    for(let x=0; x<WORLD_W; x+=64){
      ground.create(x+32, groundY, 'tile_ground').refreshBody();
    }

    // Static platforms
    LV.staticPlats.forEach(([x,y]) => platformsStatic.create(x, y, 'platform').refreshBody());

    // Moving platforms
    const createdMovers = [];
    LV.movingPlats.forEach(p => {
      const s = platformsMoving.create(p.x, p.y, 'platform_move');
      s.body.setAllowGravity(false); s.body.setImmovable(true);
      createdMovers.push(s);
      scene.tweens.add({ targets: s, x: p.x + p.dx, y: p.y + p.dy, yoyo: true, repeat: -1, duration: p.t, ease: 'Sine.inOut' });
    });

    // Player
    if (!player){
      player = scene.physics.add.sprite(lastCheckpoint.x, lastCheckpoint.y, 'hero');
      player.setCollideWorldBounds(true);
      player.body.setSize(22, 50).setOffset(9,6);
      cursors = scene.input.keyboard.createCursorKeys();
      keys = scene.input.keyboard.addKeys({ W: 'W', A: 'A', S: 'S', D: 'D', SPACE: 'SPACE' });
      // Atmosphere created once
      createAtmosphere(scene);
      startTime = performance.now();
    } else {
      player.setPosition(lastCheckpoint.x, lastCheckpoint.y);
      player.setVelocity(0,0);
    }

    // Enemies (patrollers)
    LV.enemies.forEach(([x,y], i) => {
      const e = enemies.create(x, y, 'enemy');
      e.body.setSize(20, 50).setOffset(10,4);
      e.setBounceX(0);
      const base = 100 + (i%3)*30 + idx*20;
      e.setVelocityX(i % 2 === 0 ? -base : base);
      e.patrolSpeed = base;
      e.nextJump = 0; // ms until next ground jump
      e.nextDJ = 0;   // ms until next double jump window
      e.dir = Math.sign(e.body.velocity.x) || 1;
      e.jumpCount = 0;
      e.stationary = false;
    });

    // Stationary sentries on some floating (moving) platforms
    createdMovers.forEach((plat, i) => {
      if (i % 2 === 0){ // place on every other moving platform
        const e = enemies.create(plat.x, plat.y - 60, 'enemy');
        e.body.setSize(20, 50).setOffset(10,4);
        e.setVelocityX(0);
        e.patrolSpeed = 0;
        e.stationary = true; // skip AI movement/jumps
        e.nextJump = 0; e.nextDJ = 0; e.jumpCount = 0;
      }
    });

    // Coins
    LV.coins.forEach(([x,y]) => {
      const c = coinsGroup.create(x, y, 'coin');
      c.setCircle(12,0,0);
    });

    // Goal
    goal = scene.physics.add.staticImage(LV.goalX, 420, 'goal');

    // Collisions
    scene.physics.add.collider(player, ground);
    scene.physics.add.collider(player, platformsStatic);
    scene.physics.add.collider(player, platformsMoving, ridePlatform, null, scene);

    scene.physics.add.collider(enemies, ground, () => {}, null, scene);
    scene.physics.add.collider(enemies, platformsStatic, () => {}, null, scene);
    scene.physics.add.collider(enemies, platformsMoving, rideEnemyPlatform, null, scene);

    // Interactions
    scene.physics.add.overlap(player, enemies, playerEnemyOverlap, null, scene);
    scene.physics.add.overlap(player, goal, reachGoal, null, scene);
    scene.physics.add.overlap(player, coinsGroup, collectCoin, null, scene);

    // Birds are hazards
    scene.physics.add.overlap(player, birds, hitBird, null, scene);

    // Camera + world bounds
    scene.cameras.main.setBounds(0, 0, WORLD_W, WORLD_H);
    scene.physics.world.setBounds(0, 0, WORLD_W, WORLD_H);
    scene.cameras.main.startFollow(player, true, 0.1, 0.1);
  }

  function ridePlatform(playerObj, plat){
    if (player.body.touching.down && plat.body.touching.up){ onMovingPlatform = plat; }
  }
  function rideEnemyPlatform(enemyObj, plat){
    if (enemyObj.body.touching.down && plat.body.touching.up){ enemyObj.x += plat.body.deltaX(); }
  }

  let jumpCount = 0;

  function update(time, delta){
    if (!sceneRef) return;
    const LVL = levelIndex + 1;

    // HUD
    const elapsedTotal = (performance.now() - startTime) / 1000;
    const elapsedLevel = (performance.now() - levelStartTime) / 1000;
    // Score: time-based (lower time â†’ higher score) + coins
    score = Math.max(0, Math.floor(100000 / (1 + elapsedTotal))) + totalCoins * 100;
    document.getElementById('hud').textContent = `Lvl ${LVL} Â· Time: ${elapsedLevel.toFixed(1)}s Â· Score: ${score} Â· Coins: ${totalCoins} Â· Lives: ${lives}`;

    if (finishedLevel) return;

    // Movement
    const left = cursors.left.isDown || keys.A.isDown;
    const right = cursors.right.isDown || keys.D.isDown;
    const onFloor = player.body.blocked.down || player.body.touching.down;

    let vx = 0;
    if (left) { vx = -230; player.setFlipX(true); }
    if (right){ vx =  230; player.setFlipX(false);} 
    player.setVelocityX(vx);

    // Jump & Double Jump (player)
    if (onFloor) jumpCount = 0; // reset on land
    const justPressed = Phaser.Input.Keyboard.JustDown(cursors.space) || Phaser.Input.Keyboard.JustDown(keys.SPACE);
    if (justPressed){
      if (onFloor || jumpCount < 2){
        player.setVelocityY(-520 - (jumpCount*30));
        jumpCount++;
        audio.beep(660, 0.08);
      }
    }

    // Ride with moving platform
    if (onMovingPlatform && onFloor){ player.x += onMovingPlatform.body.deltaX(); }
    onMovingPlatform = null;

    // Enemy AI: patrol + double-jump capability (skips stationary sentries)
    enemies.children.iterate((e) => {
      if (!e || !e.body) return;
      if (e.stationary){ e.setVelocityX(0); return; }

      const eOnFloor = e.body.blocked.down || e.body.touching.down;
      if (eOnFloor) e.jumpCount = 0;

      // maintain patrol direction
      if (e.body.blocked.left){ e.dir = 1; e.setVelocityX(e.patrolSpeed); }
      else if (e.body.blocked.right){ e.dir = -1; e.setVelocityX(-e.patrolSpeed); }

      // Ground hop if blocked or near an edge
      const shouldHop = (e.body.blocked.left || e.body.blocked.right) && eOnFloor && time > e.nextJump;
      if (shouldHop){
        e.setVelocityY(-400);
        e.jumpCount++;
        e.nextJump = time + 900 + Math.random()*500; // small cooldown
        e.nextDJ = time + 120; // allow double jump shortly after
      }

      // Opportunistic periodic hops to catch platforms
      if (eOnFloor && time > e.nextJump && Math.random() < 0.004){
        e.setVelocityY(-360);
        e.jumpCount++;
        e.nextJump = time + 1600 + Math.random()*900;
        e.nextDJ = time + 120;
      }

      // **Double Jump:** if airborne and descending, allow a second hop within a window
      if (!eOnFloor && e.jumpCount < 2 && time > e.nextDJ && e.body.velocity.y > 80){
        e.setVelocityY(-340);
        e.jumpCount++;
        e.nextDJ = time + 800; // prevent triple hops
      }
    });

    // Killzone fall (kept for safety; with smooth ground this rarely triggers)
    if (player.y > WORLD_H + 50){ respawn(sceneRef); }
  }

  function playerEnemyOverlap(playerObj, enemyObj){
    if (finishedLevel) return;
    const p = player.body; const e = enemyObj.body;
    const stomp = p.velocity.y > 100 && (player.y < enemyObj.y - 10);
    if (stomp){
      // defeat enemy
      enemyObj.disableBody(true, true);
      player.setVelocityY(-420);
      audio.beep(880, 0.08);
      totalCoins += 1; // tiny reward like a bonus coin
    } else {
      audio.beep(180, 0.12);
      respawn(sceneRef);
    }
  }

  function collectCoin(playerObj, coinObj){
    coinObj.disableBody(true, true);
    totalCoins++;
    // coin chime
    audio.beep(880, 0.06, 'sine', 0.10);
    setTimeout(() => audio.beep(1320, 0.06, 'sine', 0.10), 60);
  }

  function hitBird(playerObj, birdObj){
    if (finishedLevel) return;
    // low beep to indicate damage
    audio.beep(160, 0.12, 'square', 0.15);
    respawn(sceneRef);
  })();
</script>
</body>
</html>
